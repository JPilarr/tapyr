# -*- coding: iso-8859-1 -*-
# Copyright (C) 2011 Martin Glueck All rights reserved
# Langstrasse 4, A--2244 Spannberg. martin@mangari.org
# ****************************************************************************
# This module is part of the package JNJ.
#
# This module is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This module is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this module. If not, see <http://www.gnu.org/licenses/>.
# ****************************************************************************
#
#++
# Name
#    JNJ.Template_Media
#
# Purpose
#    The media which is defined by the used templates(s)
#
# Revision Dates
#    20-Jun-2011 (MG) Creation
#    ««revision-date»»···
#--

from   _JNJ                               import JNJ
from   _TFL                               import TFL
import _TFL._Meta.Object
from   _TFL._Meta.Once_Property           import Once_Property
from   _TFL.predicate                     import first
import  itertools

class _M_Injected_Templates_ (TFL.Meta.Object.__class__) :
    """Meta class for the injected templates which provides unique instances
       based on the used templates
    """

    Extension = {}

    def __call__ (cls, env, templates) :
        if not templates:
            return None
        key = "|".join (t.path for t in templates)
        result = cls.Extension.get (key)
        if not result :
            cls.Extension [key] = result = cls.__m_super.__call__ \
                (env, templates)
        return result
    # end def __call__

# end class _M_Injected_Templates_

class Injected_Templates (TFL.Meta.Object) :
    """Combine the media for the injected_templates of a navigation page."""

    __metaclass__ = _M_Injected_Templates_

    def __init__ (self, env, templates) :
        self.templates = templates
        self.env       = env
    # end def __init__

    @Once_Property
    def path (self) :
        return "|".join (t.path for t in self.templates)
    # end def path

    @Once_Property
    def CSS (self) :
        return first (self.templates).get_css (self.Media)
    # end def CSS

    @Once_Property
    def Media (self) :
        t     = first    (self.templates)
        return t.get_Media \
            ( self.env.CSS_Parameters
            , itertools.chain (* (t.templates for t in self.templates))
            )
    # end def Media

# end class Injected_Templates

class Template_Media (TFL.Meta.Object) :
    """Container for the autogenerated medias of a nabigation page."""

    def __init__ (self, template, injected_templates = None) :
        self.template           = template
        self.injected_templates = injected_templates
    # end def __init__

    @Once_Property
    def inline_CSS (self) :
        T  = self.template
        IT = self.injected_templates
        return \
            (  ( T and  T.CSS and not  T.css_href)
            or (IT and IT.CSS and not IT.css_href)
            )
    # end def inline_CSS

    @property
    def CSS (self) :
        result = []
        for T in self.template, self.injected_templates :
            if  T and T.CSS and not getattr ( T, "css_href", False) :
                result.append (T.CSS)
        return "\n".join (result)
    # end def CSS

    @Once_Property
    def css_hrefs (self) :
        result = []
        for T in self.template, self.injected_templates :
            if  T and getattr ( T, "css_href", False) :
                result.append (T.css_href)
        return result
    # end def css_hrefs

# end class Template_Media


if __name__ != "__main__" :
    JNJ._Export ("*")
### __END__ JNJ.Template_Media
