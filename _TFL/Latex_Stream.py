#! /usr/bin/python
# Copyright (C) 1999 TTTech Computertechnik GmbH. All rights reserved
# Schönbrunnerstraße 7, A--1040 Wien, Austria. office@tttech.com
# ****************************************************************************
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# ****************************************************************************
#
#++
# Name
#    TFL/Latex_Stream
#
# Purpose
#    Comfortable output stream for a Latex source file
#
# Revision Dates
#    28-Jun-1999 (MG) Creation
#    10-Oct-2000 (RM) Added some methodes to the Latex_Stream and all the nice
#                     TeX wrappers.
#    23-Oct-2000 (RM) Added fnode and made other commands more robust
#    25-Oct-2000 (RM) Added constructor which calls file_header
#    26-Oct-2000 (RM) psframe must handle floats not only ints
#    27-Oct-2000 (RM) Automatic generation of most of the functions
#    31-Oct-2000 (RM) Added class Figure_
#    30-Jan-2001 (RMA) Changed to Environment.username
#    21-Sep-2001 (MG) `item` changed to use `fpul` instead of implementing
#                     the same functionally twice
#    21-Sep-2001 (MG) `begin_pspicture`: allow only on pair of borders.
#    21-Sep-2001 (RMA) Corrected _remove_white
#    26-Sep-2001 (MG) Moved into package `TFL`
#    26-Sep-2001 (MG) Call of `file_header` removed from
#                     `Latex_Stream.__init__`
#    26-Sep-2001 (MG) `*_document`, include, and `input` added
#    10-Jun-2002 (RMA) Short name support
#    ««revision-date»»···
#--

from    Formatted_Stream import Formatted_Stream
import  re
import  time
import  sys
import  sos
import  string
import  Environment

class Latex_Stream (Formatted_Stream) :
    """Formatted output stream fot a LaText source file."""

    __Ancestor        = Ancestor = Formatted_Stream

    comment_line_head = "%"
    comment_line_tail = ""

    def __init__ (self, file = None, indent_delta = 2, open_as = "w") :
        self.__Ancestor.__init__ (self, file, indent_delta, open_as)
    # end def __init__

    def file_header (self, filetype, toolname = None, comment_char = "") :
        if toolname == None :
            toolname = sys.argv [0]

        user = " by user " + Environment.username

        self.fputl ( "%s %s"              % (comment_char, filetype)
                   , "%s generated by %s" % (comment_char, toolname)
                   , "%s written on %s%s"
                       % ( comment_char
                         , time.strftime ( "%a %d-%b-%Y %H:%M:%S"
                                         , time.localtime (time.time ())
                                         )
                         , user
                         )
                   )
        self.put_soft_line ()
    # end def file_header

    def begin_section (self, name, attributes = "") :
        """Begin of new section"""
        self.putl   ("", r"\section{%s}%s" % (name, attributes))
        if insert_newline :
            self.put_soft_line ()
        self.indent ()
    # end def begin_section

    end_section  = Formatted_Stream.deindent

    def begin_subsection (self, name, attributes = "") :
        """Begin of a new subsection"""
        if not self.at_bol :
            self.putl ()
        self.putl   ("", r"\subsection{%s}%s" % (name, attributes), "")
        self.indent ()
    # end def begin_subsection

    end_subsection  = Formatted_Stream.deindent

    def _begin_block (self, name, attributes = "") :
        """Write the beginning `\begin {}' statement for a block-statement.
        """
        if not self.at_bol :
            self.putl ()
        self.putl (r"\begin{%s}%s" % (name, attributes))
        self.indent ()
    # end def _begin_block

    def _end_block (self, name, attributes = "") :
        """Write the end `\end {}' statement for a block-statement.
        """
        self.deindent ()
        self.putl (r"\end{%s}%s" % (name, attributes))
    # end def _begin_block

    def begin_description (self) :
        """Write the beginning of a Tdescription block."""
        self._begin_block ("Tdescription")
    # end def begin_description

    def end_description (self) :
        """Write the end of a Tdescription block"""
        self._end_block ("Tdescription")
    # end def end_description

    def begin_document (self) :
        self._begin_block ("document")
    # end def begin_document

    def end_document (self) :
        self._end_block ("document")
    # end def end_document

    def input (self, filename) :
        self.putl(r"\input{%s}" % filename)
    # end def input

    def include (self, filename) :
        self.putl(r"\include{%s}" % filename)
    # end def include

    def item (self, item_name, text, item_length = 0, item_indent_only = None) :
        """Write a `item' statement for a block structure to the stream."""
        item = r"\item "
        if item_indent_only and len (text) == 1 :
            text      = "%s %s" % (item_name, text [0])
            item_name = item
        else :
            item_name = item + item_name + " "
        self.fputl (text, first_head = item_name, break_intend = item_length)
    # end def item

    def item_list (self, * name_text_pairs) :
        """"""
        item_len = 0
        for name, text in name_text_pairs :
            item_len = max (len (name), item_len)
        item_len = item_len + 1
        for name, text in name_text_pairs :
            self.item (name, text, item_len)
    # end def item_list

    def _caption_label (self, cap, label_, shortname) :
      if cap:
        self.putl (caption (cap, shortname))
      if label_:
        self.putl (label (label_))
    # end def _caption_label

    def begin_center (self) :
        self._begin_block ("center")
    # end def begin_center

    def end_center (self) :
        self._end_block ("center")
    # end def end_center

    def begin_picture (self, width = 0, height = 0) :
        attri = "(%f,%f)" % (width, height)
        self._begin_block ("picture", attri)
    # end def begin_picture

    def end_picture (self) :
        self._end_block ("picture")
    # end def end_picture

    def begin_pspicture (self, x1, y1, x2 = None, y2 = None) :
        attr  = []
        for x, y in (x1, y1), (x2, y2) :
            if (x != None) and (y != None) :
                attr.append ("(%f,%f)" % (x, y))
        attri = string.join (attr, "")
        self._begin_block ("pspicture", attri)
    # end def begin_pspicture

    def end_pspicture (self) :
        self._end_block ("pspicture")
    # end def end_pspicture

    def begin_figure (self, caption = None, label = None, shortlabel = None) :
        self._begin_block ("figure", "[htp]")
        self._caption_label (caption, label, shortlabel)
    # end def begin_figure

    def end_figure (self, caption = None, label = None, shortlabel = None) :
        self._caption_label (caption, label, shortlabel)
        self._end_block ("figure")
    # end def end_figure

# end class Latex_Stream

#----------------------------------------------------------------------
class Figure_ :

    def __init__ (self, name, outdir = "auto", prefix = "") :
        self.name   = name
        filename    = string.replace (string.lower (name), " ", "_")
        filename    = sos.path.join (outdir, prefix + filename)
        self.stream = Latex_Stream (filename + ".tex")

        self.preamble     (self.name)
        self.picture      ()
        self.epilog       (self.name)
        self.stream.close ()
    # end def __init__

    def _remove_white (self, s) :
        return filter (lambda c : c not in string.whitespace, s)
    # end def _remove_white

    def preamble (self, graphic_name) :
        self.stream.begin_figure ()
        self.stream.putl         (r"\setlength{\unitlength}{1cm}")
        self.stream.begin_center ()
    # end def preamble

    def epilog (self, graphic_name) :
        file = self.stream
        label  = "fig:" + self._remove_white (graphic_name)
        file.end_center ()
        file.end_figure (graphic_name, label)
    # end def epilog

# end class Figure_

#----------------------------------------------------------------------

class Dir_Node :
    """ Class for making directory trees with PsTricks.
        Simple instaniate nodes and add children with add.

        root = Dir_Node ("C:")
        root.add (Dir_Node ("Programme"))

        It also features empty -- no names -- nodes which are usefull
        as collections.
    """

    indent    = 1
    vertical  = 0.4
    options   = None
    factor    = 2.0/4

    __id      = 0


    #----------------------------------------------------------------------

    def __init__ (self, name = None) :
        self.name = name
        self.children = []
        self.identifier = "%s" % self._new_id ()
    # end def __init__

    def add (self, *children) :
        for child in children :
          self.children.append (child)
        return self
    # end def add

    def write (self, file, x = 0, y = 0) :
        return self._rec_write (file, x, y)
    # end def write

    #----------------------------------------------------------------------

    def _new_id (self) :
        Dir_Node.__id = Dir_Node.__id + 1
        return Dir_Node.__id
    # end def _new_id

    def _node_label (self, x, y, identifier) :
        return "%d%d%s" % (x, y, identifier)
    # end def _node_label

    def _rec_write (self, file, x = 0, y = 0) :
        _y = y

        if self.name:
            file.putl ("%")
            file.putl (pnode ( x + (1 - self.factor) * self.indent
                             , y - 0.2, self.identifier + "_D"
                             )
                      )
            file.putl (pnode (x, y, self.identifier + "_"))
            file.putl (uput (0, x, y, self.name))

            nodelabel = self._node_label (x - self.indent, y, self.identifier)
            file.putl ( ncline ( "-"
                               , nodelabel
                               , self.identifier + "_", self.options
                               )
                      )
            x = x + self.indent
        else :
            file.putl (pnode ( x - self.factor * self.indent, y
                             , self.identifier + "_D"
                             )
                      )
            y = y + self.vertical

        nodelabel = None

        for child in self.children :
            file.indent ()

            y = y - self.vertical

            nodelabel = self._node_label (x - self.indent, y, child.identifier)
            file.putl (pnode (x - self.factor*self.indent, y, nodelabel))
            y = y + child._rec_write (file, x, y)

            file.deindent ()
            file.put_soft_line ()

        if nodelabel:
            file.putl (ncline ("-", self.identifier + "_D", nodelabel))

        return y - _y
    # end def _rec_write

#end class Dir_Node



#----------------------------------------------------------------------

def vspace (length, unit = "cm") :
    return r"\vspace{%f%s}" % (length, unit)


def pnode (x, y, label) :
    return r"\pnode(%f,%f){%s}" % (x, y, label)

def rput (x, y, text) :
    return r"\rput(%f,%f){%s}" % (x, y, text)

def psframe (x1, y1, x2, y2, options = None) :
    s = r"\psframe"
    if options :
      s = s + "[" + options + "]"
    return s + "(%f,%f)(%f,%f)" % (x1,  y1,  x2, y2)

def fnode (x, y, name, width = None, height = None) :
    param = ""
    if width :
        param = param + "framesize=%s" % width
        if height :
            param = param + " %s" % height

    if param :
        param = "[" + param + "]"

    return r"\fnode%s(%f,%f){%s}" % (param, x, y, name)


def latex_cmd (name, options, *args) :
    cmd = r"\%s" % name
    if options :
        cmd = cmd + "[" + options + "]"
    for arg in args:
        cmd = cmd + "{" + "%s" % arg + "}"
    return cmd


#----------------------------------------------------------------------


def psset (name, value) :
    return r"\psset{%s=%s}" % (name, value)

def uput (angle, x, y, text) :
    return r"\uput[%s](%f,%f){%s}" % (angle, x, y, text)

#----------------------------------------------------------------------


# Commands with one parameter
_commands1          = [ "textsf", "texttt", "textbf", "centering"
                      , "tiny",   "footnotesize", "small", "smaller"
                      , "label",  "caption"
                      , "rotateleft", "psovalbox", "psframebox"
                      , "thput", "tvput"
                      , "naput", "ncput", "nbput"
                      ]
# Command with two parameters
_commands2          = [ "parbox"
                      , "rnode", "Rnode"
                      ]

# Command with three parameters
_commands3          = [ "ncangles", "ncarc", "ncloop", "ncline"
                      ]

#----------------------------------------------------------------------

for c in _commands1 :
  s = "def %s (p, options = None) : " \
      "  return latex_cmd (\"%s\", options, p)" % (c, c)
  exec (s)

for c in _commands2 :
  s = "def %s (p1, p2, options = None) :" \
      "  return latex_cmd (\"%s\", options, p1, p2)" % (c, c)
  exec (s)


for c in _commands3 :
  s = "def %s (p1, p2, p3, options = None) :" \
      "  return latex_cmd (\"%s\", options, p1, p2, p3)" % (c, c)
  exec (s)

### __END__ TFL/Latex_Stream
from _TFL import TFL
TFL._Export ("*")
