# -*- coding: iso-8859-1 -*-
# Copyright (C) 2009 Mag. Christian Tanzer. All rights reserved
# Glasauergasse 32, A--1130 Wien, Austria. tanzer@swing.co.at
# ****************************************************************************
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Library General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public
# License along with this library; if not, write to the Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
# ****************************************************************************
#
#++
# Name
#    MOM.__doc__
#
# Purpose
#    Documentation and test for MOM meta object model
#
# Revision Dates
#    18-Oct-2009 (CT) Creation
#     4-Nov-2009 (CT) Creation continued
#     4-Nov-2009 (MG) `Beaver` and `Otter` added
#    23-Nov-2009 (CT) Creation continued..
#    24-Nov-2009 (CT) Creation continued...
#    25-Nov-2009 (CT) Creation continued....
#    27-Nov-2009 (CT) Creation continued.....
#    27-Nov-2009 (MG) Order of test cases changed, use `list` operator in
#                     some tests
#    ««revision-date»»···
#--

dt_form = \
"""
How to define and use essential object models
==============================================

Using `MOM`, an essential object model is specified by deriving
classes from :class:`MOM.Object<_MOM.Object.Object>`,
:class:`MOM.Named_Object<_MOM.Object.Named_Object>`, or from one of
the descendents of :class:`MOM.Link<_MOM.Link.Link>`.

Each essential class must be defined inside a
:class:`TFL.Package_Namespace<_TFL.Package_Namespace.Package_Namespace>`
and the class definition must contain an explicit or inherited
reference :attr:`Package_NS<_MOM.Entity.Package_NS>` to that package
namespace.

Normally, each essential class is defined in a module of its own. In
some cases, a single module might define more than one essential
class.

The module `_MOM.import_MOM` provides all classes necessary to define
essential object or link types and is meant to be imported like::

    >>> from _MOM.import_MOM import *

An essential class as defined by its module isn't usable before an
app-type is created.

    >>> BMT.Person
    <class 'BMT.Person' [Spec Essence]>
    >>> BMT.Rodent
    <class 'BMT.Rodent' [Spec Essence]>
    >>> BMT.Beaver
    <class 'BMT.Beaver' [Spec Essence]>
    >>> BMT.Person_owns_Trap
    <class 'BMT.Person_owns_Trap' [Spec Essence]>
    >>> BMT.Person.last_name
    Traceback (most recent call last):
        ...
    AttributeError: type object 'Person' has no attribute 'last_name'


Application type
----------------

Before an essential object model can be used, the
:class:`application type<_MOM.App_Type.App_Type>` and at least one
:class:`derived application type<_MOM.App_Type._App_Type_D_>` must be
defined:

    >>> %(import_EMS)s as EMS
    >>> %(import_DBW)s as DBW
    >>> apt = MOM.App_Type ("BMT", BMT).Derived (EMS, DBW)

Creating a derived app-type replaces the specification of the
essential classes with bare essential classes:

    >>> BMT.Person
    <class 'BMT.Person' [Bare Essence]>
    >>> BMT.Rodent
    <class 'BMT.Rodent' [Bare Essence]>
    >>> BMT.Beaver
    <class 'BMT.Beaver' [Bare Essence]>
    >>> BMT.Person_owns_Trap
    <class 'BMT.Person_owns_Trap' [Bare Essence]>

and derives an app-type specific entity-type for each of the essential
classes:

    >>> ET_Id_Entity = apt.entity_type ("MOM.Id_Entity")
    >>> ET_Named_Obj = apt.entity_type ("MOM.Named_Object")
    >>> ET_Person    = apt.entity_type ("BMT.Person")
    >>> ET_Mouse     = apt ["BMT.Mouse"]
    >>> ET_Rat       = apt ["BMT.Rat"]
    >>> ET_Rodent    = apt ["BMT.Rodent"]
    >>> ET_Trap      = apt ["BMT.Trap"]
    >>> ET_Supertrap = apt ["BMT.Supertrap"]

For each `entity_type` with a unique :attr:`epk_sig`, the meta
machinery automatically creates a `__init__` method matching the
`epk_sig`. These autogenerated `__init__` methods ensure that the
required parameters are passed for the
:ref:`essential primary keys<essential-primary-keys>`.

    .. ### DBW-specific start

    >>> for et in apt._T_Extension :
    ...   if (et.epk_sig and "__init__" in et.__dict__ and
    ...       hasattr (et.__init__, "source_code")) :
    ...     print "***", et.type_name, "***", et.__init__.i_bases
    ...     print et.__init__.source_code
    ...
    *** MOM.Link *** (<class 'MOM.Id_Entity' [BMT__Hash__XXX]>,)
    def __init__ (self, left, right, * args, ** kw) :
        return self._MOM_Entity__init__ (self, left, right, * args, ** kw)
    <BLANKLINE>
    *** MOM.Link3 *** (<class 'MOM.Link' [BMT__Hash__XXX]>,)
    def __init__ (self, left, middle, right, * args, ** kw) :
        return self._MOM_Entity__init__ (self, left, middle, right, * args, ** kw)
    <BLANKLINE>
    *** MOM.Link2_Ordered *** (<class 'MOM.Link' [BMT__Hash__XXX]>,)
    def __init__ (self, left, right, seq_no, * args, ** kw) :
        return self._MOM_Entity__init__ (self, left, right, seq_no, * args, ** kw)
    <BLANKLINE>
    *** MOM.Named_Object *** (<class 'MOM.Object' [BMT__Hash__XXX]>,)
    def __init__ (self, name, * args, ** kw) :
        return self._MOM_Entity__init__ (self, name, * args, ** kw)
    <BLANKLINE>
    *** BMT.Location *** (<class 'MOM.Object' [BMT__Hash__XXX]>,)
    def __init__ (self, lon, lat, * args, ** kw) :
        return self._MOM_Entity__init__ (self, lon, lat, * args, ** kw)
    <BLANKLINE>
    *** BMT.Person *** (<class 'MOM.Object' [BMT__Hash__XXX]>,)
    def __init__ (self, last_name, first_name, * args, ** kw) :
        return self._MOM_Entity__init__ (self, last_name, first_name, * args, ** kw)
    <BLANKLINE>
    *** BMT.Trap *** (<class 'MOM.Named_Object' [BMT__Hash__XXX]>,)
    def __init__ (self, name, serial_no, * args, ** kw) :
        return self._MOM_Entity__init__ (self, name, serial_no, * args, ** kw)
    <BLANKLINE>

The app-type specific entity-types are ready to be used by
:class:`scopes<_MOM.Scope.Scope>` and their
:mod:`etype managers<_MOM.E_Type_Manager>`:

    >>> ET_Person
    <class 'BMT.Person' [BMT__Hash__XXX]>
    >>> ET_Person.Essence
    <class 'BMT.Person' [Bare Essence]>
    >>> ET_Person.E_Spec
    <class 'BMT.Person' [Spec Essence]>
    >>> ET_Person.primary
    [String `last_name`, String `first_name`]
    >>> [attr.__class__ for attr in ET_Person.primary]
    [<class '_MOM._Attr.Kind.Primary'>, <class '_MOM._Attr.Kind.Primary'>]
    >>> ET_Person.required
    []
    >>> ET_Person.optional
    []

    >>> ET_Mouse.primary
    [Name `name`]
    >>> ET_Mouse.required
    [Float `weight`]
    >>> ET_Mouse.optional
    [String `color`]
    >>> sorted (ET_Mouse.attributes.itervalues (), key = TFL.Getter.name)
    [Object `catcher`, String `color`, Boolean `electric`, Int `is_used`, Name `name`, Float `weight`, Boolean `x_locked`]

    >>> sorted (ET_Trap._Attributes._own_names)
    ['catch', 'location', 'max_weight', 'owner', 'serial_no', 'setter']
    >>> sorted (ET_Supertrap._Attributes._own_names)
    []
    >>> sorted (ET_Trap._Attributes._names)
    ['catch', 'electric', 'is_used', 'location', 'max_weight', 'name', 'owner', 'serial_no', 'setter', 'x_locked']
    >>> sorted (ET_Supertrap._Attributes._names)
    ['catch', 'electric', 'is_used', 'location', 'max_weight', 'name', 'owner', 'serial_no', 'setter', 'x_locked']
    >>> sorted (ET_Trap.attributes.itervalues (), key = TFL.Getter.name)
    [Object `catch`, Boolean `electric`, Int `is_used`, Object `location`, Float `max_weight`, Name `name`, Object `owner`, Int `serial_no`, Object `setter`, Boolean `x_locked`]
    >>> sorted (ET_Supertrap.attributes.itervalues (), key = TFL.Getter.name)
    [Object `catch`, Boolean `electric`, Int `is_used`, Object `location`, Float `max_weight`, Name `name`, Object `owner`, Int `serial_no`, Object `setter`, Boolean `x_locked`]

    >>> sorted (ET_Id_Entity.relevant_roots)
    ['BMT.Location', 'BMT.Person', 'BMT.Person_owns_Trap',\
 'BMT.Person_sets_Trap_at_Location', 'BMT.Rodent', 'BMT.Rodent_in_Trap',\
 'BMT.Trap']
    >>> ET_Person.relevant_root
    <class 'BMT.Person' [BMT__Hash__XXX]>
    >>> ET_Rodent.relevant_root
    <class 'BMT.Rodent' [BMT__Hash__XXX]>
    >>> ET_Mouse.relevant_root
    <class 'BMT.Rodent' [BMT__Hash__XXX]>

    >>> sorted (ET_Person.children)
    []
    >>> sorted (ET_Rodent.children)
    ['BMT.Mouse', 'BMT.Rat']
    >>> sorted (ET_Rodent.children.itervalues (), key = TFL.Getter.type_name)
    [<class 'BMT.Mouse' [BMT__Hash__XXX]>,\
 <class 'BMT.Rat' [BMT__Hash__XXX]>]
    >>> sorted (ET_Rat.children)
    []

    >>> sorted (apt.etypes)
    ['BMT.Beaver', 'BMT.Location', 'BMT.Mouse', 'BMT.Otter', 'BMT.Person', 'BMT.Person_owns_Trap', 'BMT.Person_sets_Trap_at_Location', 'BMT.Rat', 'BMT.Rodent', 'BMT.Rodent_in_Trap', 'BMT.Supertrap', 'BMT.Trap', 'MOM.An_Entity', 'MOM.Entity', 'MOM.Id_Entity', 'MOM.Link', 'MOM.Link2', 'MOM.Link2_Ordered', 'MOM.Link3', 'MOM.Named_Object', 'MOM.Object', 'MOM.Sequence_Number']
    >>> [t.type_name for t in apt._T_Extension]
    ['MOM.Entity', 'MOM.An_Entity', 'MOM.Id_Entity', 'MOM.Link', 'MOM.Link2', 'MOM.Link3', 'MOM.Link2_Ordered', 'MOM.Object', 'MOM.Named_Object', 'MOM.Sequence_Number', 'BMT.Location', 'BMT.Person', 'BMT.Rodent', 'BMT.Mouse', 'BMT.Rat', 'BMT.Beaver', 'BMT.Otter', 'BMT.Trap', 'BMT.Supertrap', 'BMT.Rodent_in_Trap', 'BMT.Person_owns_Trap', 'BMT.Person_sets_Trap_at_Location']
    >>> for t in apt._T_Extension [2:] :
    ...     print "%%-35s %%s" %% (t.type_name, t.epk_sig)
    MOM.Id_Entity                       ()
    MOM.Link                            ('left', 'right')
    MOM.Link2                           ('left', 'right')
    MOM.Link3                           ('left', 'middle', 'right')
    MOM.Link2_Ordered                   ('left', 'right', 'seq_no')
    MOM.Object                          ()
    MOM.Named_Object                    ('name',)
    MOM.Sequence_Number                 ('seq_nr',)
    BMT.Location                        ('lon', 'lat')
    BMT.Person                          ('last_name', 'first_name')
    BMT.Rodent                          ('name',)
    BMT.Mouse                           ('name',)
    BMT.Rat                             ('name',)
    BMT.Beaver                          ('name',)
    BMT.Otter                           ('name',)
    BMT.Trap                            ('name', 'serial_no')
    BMT.Supertrap                       ('name', 'serial_no')
    BMT.Rodent_in_Trap                  ('left', 'right')
    BMT.Person_owns_Trap                ('left', 'right')
    BMT.Person_sets_Trap_at_Location    ('left', 'middle', 'right')
    >>> for t in apt._T_Extension [2:] :
    ...     print "%%s%%s    %%s" %% (t.type_name, NL, t.sorted_by.criteria)
    MOM.Id_Entity
        (<bound method M_E_Type_Id.sort_key of <class 'MOM.Id_Entity' [BMT__Hash__XXX]>>,)
    MOM.Link
        (<bound method M_E_Type_Link.sort_key of <class 'MOM.Link' [BMT__Hash__XXX]>>,)
    MOM.Link2
        (<bound method M_E_Type_Link2.sort_key of <class 'MOM.Link2' [BMT__Hash__XXX]>>,)
    MOM.Link3
        (<bound method M_E_Type_Link3.sort_key of <class 'MOM.Link3' [BMT__Hash__XXX]>>,)
    MOM.Link2_Ordered
        (<bound method M_E_Type_Link2_Ordered.sort_key of <class 'MOM.Link2_Ordered' [BMT__Hash__XXX]>>,)
    MOM.Object
        (<bound method M_E_Type_Object.sort_key of <class 'MOM.Object' [BMT__Hash__XXX]>>,)
    MOM.Named_Object
        ('name',)
    MOM.Sequence_Number
        ('seq_nr',)
    BMT.Location
        ('lon', 'lat')
    BMT.Person
        ('last_name', 'first_name')
    BMT.Rodent
        ('name',)
    BMT.Mouse
        ('name',)
    BMT.Rat
        ('name',)
    BMT.Beaver
        ('name',)
    BMT.Otter
        ('name',)
    BMT.Trap
        ('name', 'serial_no')
    BMT.Supertrap
        ('name', 'serial_no')
    BMT.Rodent_in_Trap
        ('left.name', 'right.name', 'right.serial_no')
    BMT.Person_owns_Trap
        ('left.last_name', 'left.first_name', 'right.name', 'right.serial_no')
    BMT.Person_sets_Trap_at_Location
        ('left.last_name', 'left.first_name', 'middle.name', 'middle.serial_no', 'right.lon', 'right.lat')

    >>> sorted (ET_Person.link_map, key = TFL.Getter.type_name)
    [<class 'BMT.Person_owns_Trap' [BMT__Hash__XXX]>,\
 <class 'BMT.Person_sets_Trap_at_Location' [BMT__Hash__XXX]>]
    >>> sorted (ET_Trap.link_map.iteritems (), key = TFL.Getter [0].type_name)
    [(<class 'BMT.Person_owns_Trap' [BMT__Hash__XXX]>, set([Trap `right`])),\
 (<class 'BMT.Person_sets_Trap_at_Location' [BMT__Hash__XXX]>,\
 set([Trap `middle`])), (<class 'BMT.Rodent_in_Trap' [BMT__Hash__XXX]>,\
 set([Trap `right`]))]

    .. ### DBW-specific finish

Scope
-----

A :class:`scope<_MOM.Scope.Scope>` manages the instances of essential
object and link types.

    >>> scope = MOM.Scope (apt)

For each :attr:`~_MOM.Entity.Package_NS` defining essential
classes, the `scope` provides an object holding
:class:`object managers<_MOM.E_Type_Manager.Object>` and
:class:`link managers<_MOM.E_Type_Manager.Link>`
that support instance creation and queries:

    .. ### DBW-specific start

    >>> scope.MOM.Id_Entity
    <E_Type_Manager for MOM.Id_Entity of scope BMT__Hash__XXX>
    >>> scope.BMT.Person
    <E_Type_Manager for BMT.Person of scope BMT__Hash__XXX>
    >>> scope.BMT.Person_owns_Trap
    <E_Type_Manager for BMT.Person_owns_Trap of scope BMT__Hash__XXX>

    .. ### DBW-specific finish

.. _`essential-primary-keys`:

Identity
--------

Essential objects and links have identity, i.e., each object or link
can be uniquely identified. This identity is specified by a set of (so
called `primary`) attributes that together define the
`essential primary key`, short `epk`, for the entity in question. If
there is more than one primary attribute, the sequence of the
attributes is defined by their :attr:`rank` and :attr:`name`.

Essential objects identified by a simple, unstructured `name` are
defined by classes derived from
:class:`MOM.Named_Object<_MOM.Object.Named_Object>`. All other
essential objects are defined by classes derived from
:class:`MOM.Object<_MOM.Object.Object>` that specify one or more
essential attributes of kind :class:`~_MOM._Attr.Kind.Primary`.

Essential links are identified by the associated objects (the link's
roles) and any other, if any, primary attributes defined for the link
in question:

- Binary links are derived from :class:`MOM.Link2<_MOM.Link.Link2>`
  and identified by the link roles :attr:`left<_MOM.Link.Link2.left>`
  and :attr:`right<_MOM.Link.Link2.right>` plus any other primary
  attributes.

- Binary ordered links are derived from
  :class:`MOM.Link2_Ordered<_MOM.Link.Link2_Ordered>`
  and identified by the link roles
  :attr:`left<_MOM.Link.Link2_Ordered.left>`,
  :attr:`right<_MOM.Link.Link2_Ordered.right>`, and
  :attr:`seq_no<_MOM.Link.Link2_Ordered.seq_no>` plus any other primary
  attributes.

- Ternary links are derived from :class:`MOM.Link3<_MOM.Link.Link3>`
  and identified by the link roles :attr:`left<_MOM.Link.Link3.left>`,
  :attr:`middle<_MOM.Link.Link3.middle>`,
  and :attr:`right<_MOM.Link.Link3.right>` plus any other primary
  attributes.

Object and link creation
-------------------------

One creates objects or links by calling the etype manager of the
appropriate class:

    >>> scope.MOM.Named_Object ("foo")
    Traceback (most recent call last):
      ...
    Partial_Type: MOM.Named_Object

    >>> p     = scope.BMT.Person     ("Luke", "Lucky")
    >>> p
    BMT.Person ('Luke', 'Lucky')
    >>> q     = scope.BMT.Person     ("Dog",  "Snoopy")
    >>> l1    = scope.BMT.Location   (-16.268799, 48.189956)
    >>> l2    = scope.BMT.Location   (-16.740770, 48.463313)
    >>> m     = scope.BMT.Mouse      ("Mighty_Mouse")
    >>> b     = scope.BMT.Beaver     ("Toothy_Beaver")
    >>> r     = scope.BMT.Rat        ("Rutty_Rat")
    >>> axel  = scope.BMT.Rat        ("Axel")
    >>> t1    = scope.BMT.Trap       ("X", 1)
    >>> t2    = scope.BMT.Trap       ("X", 2)
    >>> t3    = scope.BMT.Trap       ("Y", 1)
    >>> t4    = scope.BMT.Trap       ("Y", 2)

    >>> RiT   = scope.BMT.Rodent_in_Trap
    >>> PoT   = scope.BMT.Person_owns_Trap
    >>> PTL   = scope.BMT.Person_sets_Trap_at_Location

    >>> RiT (p, t4)
    Traceback (most recent call last):
      ...
    ValueError: BMT.Person ('Luke', 'Lucky') not eligible for attribute left,
        must be instance of BMT.Rodent
    >>> RiT (m, t1)
    BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1))
    >>> RiT (m, t2)
    Traceback (most recent call last):
      ...
    Multiplicity_Errors: BMT.Rodent_in_Trap, [Maximum number of links for 'Mighty_Mouse' is 1 ((BMT.Mouse ('Mighty_Mouse'), BMT.Trap ('X', 2)), [BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1))])]
    >>> RiT (r, t3)
    BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1))
    >>> RiT (axel, t2)
    BMT.Rodent_in_Trap (('Axel'), ('X', 2))

    >>> PoT (p, t1)
    BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 1))
    >>> PoT (p, t2)
    BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 2))
    >>> PoT (q, t3)
    BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1))
    >>> PoT (("Tin", "Tin"), t4)
    BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2))

    >>> t1.setter, t1.location
    (None, None)
    >>> PTL (p, t1, l1)
    BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956))
    >>> t1.setter, t1.location
    (BMT.Person ('Luke', 'Lucky'), BMT.Location (-16.268799, 48.189956))
    >>> t2.setter, t2.location
    (None, None)
    >>> PTL (p, t2, l2)
    BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313))
    >>> t2.setter, t2.location
    (BMT.Person ('Luke', 'Lucky'), BMT.Location (-16.74077, 48.463313))
    >>> t3.setter, t3.location
    (None, None)
    >>> PTL (p, t3, l2)
    BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313))
    >>> t3.setter, t3.location
    (BMT.Person ('Luke', 'Lucky'), BMT.Location (-16.74077, 48.463313))

Queries
-------

One queries the object model by calling query methods of the
appropriate etype manager. Strict queries they return only instances
of the essential class in question,
but not instances of derived classes. Non-strict queries are
transitive, i.e., they return instances of the essential class in
question and all its descendents. For partial types, strict queries
return nothing. By default, queries are non-strict (transitive).
Passing `strict = True` to a query makes it strict.


The query :meth:`instance<_MOM.E_Type_Manager.E_Type_Manager.instance>` can
only be applied to `E_Type_Managers` for essential types that are, or
inherit, a `relevant_root`:

    >>> scope.MOM.Object.instance ("Mighty_Mouse")
    Traceback (most recent call last):
      ...
    TypeError: Cannot query `instance` of non-root type `MOM.Object`.
    Use one of the types BMT.Location, BMT.Person, BMT.Rodent, BMT.Trap instead.

    >>> scope.MOM.Named_Object.instance ("Mighty_Mouse")
    Traceback (most recent call last):
      ...
    TypeError: Cannot query `instance` of non-root type `MOM.Named_Object`.
    Use one of the types BMT.Rodent, BMT.Trap instead.

    >>> scope.BMT.Rodent.instance ("Mighty_Mouse")
    BMT.Mouse ('Mighty_Mouse')
    >>> print scope.BMT.Rat.instance ("Mighty_Mouse")
    None

    >>> PoT.instance (('Dog', 'Snoopy'), ('Y', 1))
    BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1))
    >>> PoT.instance (('Dog', 'Snoopy'), ('X', 2))
    >>> print PoT.instance (("Man", "Tin"), t4)
    None

The query :meth:`exists<_MOM.E_Type_Manager.E_Type_Manager.exists>`
returns a list of all `E_Type_Managers` for which an object or link
with the specified `epk` exists:

    >>> scope.MOM.Named_Object.exists ("Mighty_Mouse")
    [<E_Type_Manager for BMT.Mouse of scope BMT__Hash__XXX>]
    >>> scope.BMT.Mouse.exists ("Mighty_Mouse")
    [<E_Type_Manager for BMT.Mouse of scope BMT__Hash__XXX>]
    >>> scope.BMT.Rat.exists ("Mighty_Mouse")
    []

    >>> PoT.exists (('Dog', 'Snoopy'), ('Y', 1))
    [<E_Type_Manager for BMT.Person_owns_Trap of scope BMT__Hash__XXX>]
    >>> PoT.exists (("Man", "Tin"), t4)
    []

The queries :attr:`~_MOM.E_Type_Manager.E_Type_Manager.count`,
:attr:`~_MOM.E_Type_Manager.E_Type_Manager.count_transitive`,
:meth:`~_MOM.E_Type_Manager.E_Type_Manager.query`, and
:meth:`~_MOM.E_Type_Manager.E_Type_Manager.r_query` return the
number, or list, of instances of the specified
etype:

    >>> scope.BMT.Mouse.count
    1
    >>> list (scope.BMT.Mouse.query_s (strict = True))
    [BMT.Mouse ('Mighty_Mouse')]
    >>> scope.BMT.Mouse.count_transitive
    2
    >>> list (scope.BMT.Mouse.query_s ())
    [BMT.Mouse ('Mighty_Mouse'), BMT.Beaver ('Toothy_Beaver')]

    >>> scope.BMT.Rat.count
    2
    >>> list (scope.BMT.Rat.query_s (strict = True))
    [BMT.Rat ('Axel'), BMT.Rat ('Rutty_Rat')]
    >>> scope.BMT.Rat.count_transitive
    2
    >>> list (scope.BMT.Rat.query_s ())
    [BMT.Rat ('Axel'), BMT.Rat ('Rutty_Rat')]

    >>> scope.BMT.Rodent.count
    0
    >>> list (scope.BMT.Rodent.query_s (strict = True))
    []
    >>> scope.BMT.Rodent.count_transitive
    4
    >>> list (scope.BMT.Rodent.query_s ())
    [BMT.Rat ('Axel'), BMT.Mouse ('Mighty_Mouse'), BMT.Rat ('Rutty_Rat'), BMT.Beaver ('Toothy_Beaver')]

    >>> scope.MOM.Named_Object.count_transitive
    8
    >>> list (scope.MOM.Named_Object.query_s ())
    [BMT.Rat ('Axel'), BMT.Mouse ('Mighty_Mouse'), BMT.Rat ('Rutty_Rat'), BMT.Beaver ('Toothy_Beaver'), BMT.Trap ('X', 1), BMT.Trap ('X', 2), BMT.Trap ('Y', 1), BMT.Trap ('Y', 2)]
    >>> scope.MOM.Object.count_transitive
    13
    >>> list (scope.MOM.Object.query_s ())
    [BMT.Location (-16.74077, 48.463313), BMT.Location (-16.268799, 48.189956), BMT.Person ('Dog', 'Snoopy'), BMT.Person ('Luke', 'Lucky'), BMT.Person ('Tin', 'Tin'), BMT.Rat ('Axel'), BMT.Mouse ('Mighty_Mouse'), BMT.Rat ('Rutty_Rat'), BMT.Beaver ('Toothy_Beaver'), BMT.Trap ('X', 1), BMT.Trap ('X', 2), BMT.Trap ('Y', 1), BMT.Trap ('Y', 2)]

    >>> list (scope.MOM.Id_Entity.query_s ())
    [BMT.Location (-16.74077, 48.463313), BMT.Location (-16.268799, 48.189956), BMT.Person ('Dog', 'Snoopy'), BMT.Person ('Luke', 'Lucky'), BMT.Person ('Tin', 'Tin'), BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 2)), BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313)), BMT.Rat ('Axel'), BMT.Mouse ('Mighty_Mouse'), BMT.Rat ('Rutty_Rat'), BMT.Beaver ('Toothy_Beaver'), BMT.Rodent_in_Trap (('Axel'), ('X', 2)), BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1)), BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1)), BMT.Trap ('X', 1), BMT.Trap ('X', 2), BMT.Trap ('Y', 1), BMT.Trap ('Y', 2)]
    >>> scope.MOM.Id_Entity.count_transitive
    23

    >>> scope.MOM.Link.count_transitive
    10
    >>> list (scope.MOM.Link.query_s ())
    [BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 2)), BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313)), BMT.Rodent_in_Trap (('Axel'), ('X', 2)), BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1)), BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1))]
    >>> scope.MOM.Link2.count_transitive
    7
    >>> list (scope.MOM.Link2.query_s ())
    [BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 2)), BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2)), BMT.Rodent_in_Trap (('Axel'), ('X', 2)), BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1)), BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1))]
    >>> scope.MOM.Link3.count_transitive
    3
    >>> list (scope.MOM.Link3.query_s ())
    [BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313))]

    >>> sk_right_left = TFL.Sorted_By (RiT.right.sort_key, RiT.left.sort_key)
    >>> RiT.count_transitive
    3
    >>> show (RiT.query_s ())
    [(('Axel'), ('X', 2)), (('Mighty_Mouse'), ('X', 1)), (('Rutty_Rat'), ('Y', 1))]
    >>> show (RiT.query_s (sort_key = sk_right_left))
    [(('Mighty_Mouse'), ('X', 1)), (('Axel'), ('X', 2)), (('Rutty_Rat'), ('Y', 1))]

    >>> show (RiT.r_query_s (right = t1, strict = True))
    [(('Mighty_Mouse'), ('X', 1))]
    >>> show (RiT.r_query_s (trap = ("X", 2)))
    [(('Axel'), ('X', 2))]
    >>> show (RiT.r_query_s (trap = ("Y", "1"), strict = True))
    [(('Rutty_Rat'), ('Y', 1))]
    >>> show (RiT.r_query_s (right = m))
    []
    >>> show (RiT.r_query_s (left = "Foxy_Fox", strict = True))
    []

    >>> show (RiT.r_query_s (left = m))
    [(('Mighty_Mouse'), ('X', 1))]
    >>> show (RiT.r_query_s (rodent = "Rutty_Rat"))
    [(('Rutty_Rat'), ('Y', 1))]
    >>> show (RiT.r_query_s (left = ("Axel", ), strict = True))
    [(('Axel'), ('X', 2))]
    >>> show (RiT.r_query_s (left = "Jimmy", strict = True))
    []

    >>> PoT.count_transitive
    4
    >>> show (PoT.r_query_s (left = p))
    [(('Luke', 'Lucky'), ('X', 1)), (('Luke', 'Lucky'), ('X', 2))]
    >>> show (PoT.r_query_s (person = ("Dog",  "Snoopy")))
    [(('Dog', 'Snoopy'), ('Y', 1))]

    >>> PTL.count_transitive
    3
    >>> show (PTL.r_query_s (left = p, trap = t1))
    [(('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956))]
    >>> show (PTL.r_query_s (person = p, middle = ("X", 2)))
    [(('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (person = ("Luke", "Lucky"), trap = t3, strict = True))
    [(('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (left = q, middle = t1))
    []

    >>> show (PTL.r_query_s (left = p))
    [(('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (location = (-16.74077, 48.463313)))
    [(('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (trap = ("Y", "1")))
    [(('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (person = ("Tan", "Tan")))
    []

    >>> show (PTL.r_query_s (left = p))
    [(('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (middle = ('X', 2)))
    [(('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (right = l1))
    [(('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956))]
    >>> show (PTL.r_query_s (trap = t2, location = l2))
    [(('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (middle = ('Y', 1), right = l1))
    []
    >>> show (PTL.r_query_s (left = p, middle = ('X', 2), right = l2))
    [(('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313))]
    >>> show (PTL.r_query_s (person = p, trap = ('X', 2), location = l1))
    []
    >>> show (PTL.r_query_s (person = p, trap = ('X', 1), location = l1))
    [(('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956))]
    >>> show (PTL.r_query_s (left = ("Tan", "Tan")))
    []

    >>> show (PTL.links_of (p))
    [(('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313))]

    >>> t1
    BMT.Trap ('X', 1)
    >>> t1.all_links ()
    [BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 1)),\
 BMT.Person_sets_Trap_at_Location\
 (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)),\
 BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1))]

    .. ### DBW-specific start

    >>> list (scope)
    [BMT.Location (-16.74077, 48.463313), BMT.Location (-16.268799, 48.189956), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 2)), BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 1)), BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2)), BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1)), BMT.Rodent_in_Trap (('Axel'), ('X', 2)), BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1)), BMT.Person ('Dog', 'Snoopy'), BMT.Person ('Luke', 'Lucky'), BMT.Person ('Tin', 'Tin'), BMT.Trap ('X', 2), BMT.Trap ('Y', 1), BMT.Trap ('X', 1), BMT.Trap ('Y', 2), BMT.Beaver ('Toothy_Beaver'), BMT.Mouse ('Mighty_Mouse'), BMT.Rat ('Rutty_Rat'), BMT.Rat ('Axel'), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313))]

    .. ### DBW-specific finish

    >>> len (list (scope))
    23

Changing objects and links
---------------------------

    >>> old_id = axel.id
    >>> axel.all_links ()
    [BMT.Rodent_in_Trap (('Axel'), ('X', 2))]
    >>> axel.name = "betty"
    Traceback (most recent call last):
      ...
    AttributeError: Primary attribute `BMT.Rat.name` cannot be assigned.
    Use `set` or `set_raw` to change it.
    >>> axel.set (name = "betty")
    1
    >>> axel
    BMT.Rat ('betty')
    >>> axel.id == old_id
    True
    >>> axel.all_links ()
    [BMT.Rodent_in_Trap (('betty'), ('X', 2))]

    >>> m
    BMT.Mouse ('Mighty_Mouse')
    >>> m.color, m.weight
    (None, None)
    >>> print m.as_code ()
    BMT.Mouse ('Mighty_Mouse', )
    >>> m.color = "white"
    >>> print m.as_code ()
    BMT.Mouse ('Mighty_Mouse', color = 'white')
    >>> m.weight = 0
    Traceback (most recent call last):
      ...
    Invariant_Error: Condition `AC_check_weight_0` :  (weight > 0)
        weight = 0.0
    >>> m.set (weight = -5.0)
    Traceback (most recent call last):
      ...
    Invariant_Errors: Condition `AC_check_weight_0` :  (weight > 0)
        weight = -5.0
    >>> m.weight = 10
    >>> print m.as_code ()
    BMT.Mouse ('Mighty_Mouse', color = 'white', weight = 10.0)
    >>> m.set (color = "black", weight = 25.0)
    2
    >>> print m.as_code ()
    BMT.Mouse ('Mighty_Mouse', color = 'black', weight = 25.0)
    >>> m.set (weight = "one ton")
    Traceback (most recent call last):
      ...
    ValueError: invalid literal for float(): one ton
    >>> m.set_raw (weight = "one ton")
    Traceback (most recent call last):
      ...
    Invalid_Attribute: Can't set required attribute <'Mighty_Mouse'>.weight to `one ton`
        `unexpected EOF while parsing (<string>, line 1)` for : `weight'
         expected type  : `Float'
         got      value : `one ton -> one ton'
         of       type  : `<type 'str'>`
    >>> m.set_raw (color = "yellow", weight = "42")
    3
    >>> m.color, m.weight
    ('yellow', 42.0)
    >>> print m.as_code ()
    BMT.Mouse ('Mighty_Mouse', color = 'yellow', weight = 42.0)

    >>> print l1.as_code ()
    BMT.Location (-16.268799, 48.189956, )
    >>> l1.set (lat =  91.5)
    Traceback (most recent call last):
      ...
    Invariant_Errors: Condition `AC_check_lat_0` :  (-90.0 <= lat <= 90.0)
        lat = 91.5
    >>> l1.set (lon = 270.0)
    Traceback (most recent call last):
      ...
    Invariant_Errors: Condition `AC_check_lon_0` :  (-180.0 <= lon <= 180.0)
        lon = 270.0

    >>> rit = RiT.instance (m, t1)
    >>> print rit.as_code ()
    BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1), )
    >>> print rit.rodent.as_code ()
    BMT.Mouse ('Mighty_Mouse', color = 'yellow', weight = 42.0)
    >>> print rit.trap.as_code ()
    BMT.Trap ('X', 1, )
    >>> print rit.is_g_correct ()
    True
    >>> rit.trap.max_weight = 20
    >>> print rit.is_g_correct ()
    False
    >>> for err in rit.errors :
    ...     print err
    Condition `valid_weight` : Weight of `rodent` must not exceed `max_weight` of `trap`. (rodent.weight <= trap.max_weight)
        rodent = 'Mighty_Mouse'
        trap = ('X', 1)
        rodent.weight = 42.0
        trap.max_weight = 20.0

    >>> b.all_links ()
    []
    >>> rit.set (left = b)
    1
    >>> print rit.as_code ()
    BMT.Rodent_in_Trap (('Toothy_Beaver'), ('X', 1), )
    >>> b.all_links ()
    [BMT.Rodent_in_Trap (('Toothy_Beaver'), ('X', 1))]
    >>> rit.rodent, rit.right
    (BMT.Beaver ('Toothy_Beaver'), BMT.Trap ('X', 1))

    .. ### DBW-specific start

    >>> rit.__class__.rodent, rit.__class__.right
    (Rodent `left`, Trap `right`)

    .. ### DBW-specific finish

    >>> rit.set (rodent = m)
    1
    >>> print rit.as_code ()
    BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1), )

    >>> scope.MOM.Link.query_s ().all ()
    [BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 2)), BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313)), BMT.Rodent_in_Trap (('Mighty_Mouse'), ('X', 1)), BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1)), BMT.Rodent_in_Trap (('betty'), ('X', 2))]

    .. ### DBW-specific start

    >>> m.object_referring_attributes
    defaultdict(<type 'list'>, {BMT.Trap ('X', 1): [Object `catcher`]})
    >>> sorted (d.type_name for d in t1.dependencies)
    ['BMT.Mouse', 'BMT.Person_owns_Trap', 'BMT.Person_sets_Trap_at_Location', 'BMT.Rodent_in_Trap']

    >>> m_id  = m.id
    >>> t1_id = t1.id
    >>> t2_id = t2.id
    >>> show (scope.ems.all_links (m_id))
    [(('Mighty_Mouse'), ('X', 1))]
    >>> show (scope.ems.all_links (t1_id))
    [(('Luke', 'Lucky'), ('X', 1)), (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), (('Mighty_Mouse'), ('X', 1))]

    .. ### DBW-specific finish

    >>> t1.catch
    BMT.Mouse ('Mighty_Mouse')
    >>> m.destroy ()
    >>> t1.catch

    .. ### DBW-specific start

    >>> show (scope.ems.all_links (m_id))
    []

    >>> sorted (d.type_name for d in t1.dependencies)
    ['BMT.Person_owns_Trap', 'BMT.Person_sets_Trap_at_Location']

    .. ### DBW-specific finish

    >>> scope.MOM.Link.query_s ().count ()
    9
    >>> scope.MOM.Link.r_query_s ().all ()
    [BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 2)), BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 1), (-16.268799, 48.189956)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313)), BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1)), BMT.Rodent_in_Trap (('betty'), ('X', 2))]

    >>> t1.destroy ()

    .. ### DBW-specific start

    >>> show (scope.ems.all_links (t1_id))
    []
    >>> show (scope.ems.all_links (t2_id))
    [(('Luke', 'Lucky'), ('X', 2)), (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), (('betty'), ('X', 2))]

    .. ### DBW-specific finish

    >>> scope.MOM.Link.query_s ().all ()
    [BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1)), BMT.Person_owns_Trap (('Luke', 'Lucky'), ('X', 2)), BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('X', 2), (-16.74077, 48.463313)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313)), BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1)), BMT.Rodent_in_Trap (('betty'), ('X', 2))]

    >>> t2.destroy ()
    >>> scope.MOM.Link.query_s ().all ()
    [BMT.Person_owns_Trap (('Dog', 'Snoopy'), ('Y', 1)), BMT.Person_owns_Trap (('Tin', 'Tin'), ('Y', 2)), BMT.Person_sets_Trap_at_Location (('Luke', 'Lucky'), ('Y', 1), (-16.74077, 48.463313)), BMT.Rodent_in_Trap (('Rutty_Rat'), ('Y', 1))]

    .. ### DBW-specific start

    >>> show (scope.ems.all_links (t2_id))
    []

    .. ### DBW-specific finish

"""

__doc__ = doctest = dt_form % dict \
    ( import_DBW = "from _MOM._DBW.Session import Session"
    , import_EMS = "from _MOM._EMS.Hash    import Manager"
        ### XXX change to a real DBW
    )

from   _MOM.import_MOM       import *

BMT = TFL.Package_Namespace ("_BMT")

_Ancestor_Essence = MOM.Object

class Location (_Ancestor_Essence) :
    """Model a location of the Better Mouse Trap application."""

    Package_NS = BMT

    class _Attributes (_Ancestor_Essence._Attributes) :

        class lon (A_Float) :
            """Longitude """

            kind     = Attr.Primary
            rank     = 1
            check    = ("-180.0 <= value <= 180.0", )

        # end class lon

        class lat (A_Float) :
            """Latitude"""

            kind     = Attr.Primary
            rank     = 2
            check    = ("-90.0 <= value <= 90.0", )

        # end class lat

    # end class _Attributes

# end class Location

_Ancestor_Essence = MOM.Object

class Person (_Ancestor_Essence) :
    """Model a person of the Better Mouse Trap application."""

    Package_NS = BMT

    class _Attributes (_Ancestor_Essence._Attributes) :

        class last_name (A_String) :
            """Last name of person"""

            kind     = Attr.Primary
            rank     = 1

        # end class last_name

        class first_name (A_String) :
            """First name of person"""

            kind     = Attr.Primary
            rank     = 2

        # end class first_name

    # end class _Attributes

# end class Person

_Ancestor_Essence = MOM.Named_Object

class Rodent (_Ancestor_Essence) :
    """Model a rodent of the Better Mouse Trap application."""

    Package_NS    = BMT

    is_partial    = True

    class _Attributes (_Ancestor_Essence._Attributes) :

        class color (A_String) :
            """Color of the rodent"""

            kind     = Attr.Optional

        # end class color

        class weight (A_Float) :
            """Weight of the rodent"""

            kind     = Attr.Required
            check    = ("value > 0", )

        # end class weight

    # end class _Attributes

# end class Rodent

_Ancestor_Essence = Rodent

class Mouse (_Ancestor_Essence) :
    """Model a mouse of the Better Mouse Trap application."""

# end class Mouse

_Ancestor_Essence = Rodent

class Rat (_Ancestor_Essence) :
    """Model a rat of the Better Mouse Trap application."""

# end class Rat

_Ancestor_Essence = Mouse

class Beaver (_Ancestor_Essence) :
    """Model a beaver of the Better Mouse Trap application."""

    class _Attributes (_Ancestor_Essence._Attributes) :

        class region (A_String) :
            """In wich are lives the beaver"""

            kind     = Attr.Optional

        # end class region

    # end class _Attributes

# end class Beaver

_Ancestor_Essence = Beaver

class Otter (_Ancestor_Essence) :

    class _Attributes (_Ancestor_Essence._Attributes) :

        class river (A_String) :

            kind       = Attr.Optional
            max_length = 20

        # end class river

    # end class _Attributes

# end class Otter

_Ancestor_Essence = MOM.Named_Object

class Trap (_Ancestor_Essence) :
    """Model a trap of the Better Mouse Trap application."""

    Package_NS = BMT

    class _Attributes (_Ancestor_Essence._Attributes) :

        class serial_no (A_Int) :
            """Serial number of the trap"""

            kind     = Attr.Primary

        # end class serial_no

        class max_weight (A_Float) :
            """Maximum weight of rodent the trap can hold"""

            kind     = Attr.Optional
            check    = ("value > 0", )

        # end class max_weight

    # end class _Attributes

# end class Trap

_Ancestor_Essence = Trap

class Supertrap (_Ancestor_Essence) :
    """An enormously improved Trap."""
# end class Supertrap

_Ancestor_Essence = MOM.Link2

class Rodent_in_Trap (_Ancestor_Essence) :
    """Model a rodent caught in a trap."""

    Package_NS = BMT

    class _Attributes (_Ancestor_Essence._Attributes) :

        _Ancestor = _Ancestor_Essence._Attributes

        class left (_Ancestor.left) :
            """Rodent caught in Trap."""

            role_type     = Rodent
            max_links     = 1
            auto_cache    = "catch"

        # end class left

        class right (_Ancestor.right) :
            """Trap that caught a rodent."""

            role_type     = Trap
            max_links     = 1
            auto_cache    = "catcher"

        # end class right

    # end class _Attributes

    class _Predicates (_Ancestor_Essence._Predicates) :

        class valid_weight (Pred.Condition) :
            """Weight of `rodent` must not exceed `max_weight` of `trap`."""

            kind          = Pred.System
            assertion     = "rodent.weight <= trap.max_weight"
            attributes    = ("rodent.weight", "trap.max_weight")

        # end class valid_weight

    # end class _Predicates


# end class Rodent_in_Trap

_Ancestor_Essence = MOM.Link2

class Person_owns_Trap (_Ancestor_Essence) :

    Package_NS = BMT

    class _Attributes (_Ancestor_Essence._Attributes) :

        _Ancestor = _Ancestor_Essence._Attributes

        class left (_Ancestor.left) :
            """Person owning the Trap."""

            role_name     = "owner"
            role_type     = Person
            auto_cache    = True

        # end class left

        class right (_Ancestor.right) :
            """Trap owned by person."""

            role_type     = Trap
            max_links     = 1

        # end class right

    # end class _Attributes

# end class Person_owns_Trap

_Ancestor_Essence = MOM.Link3

class Person_sets_Trap_at_Location (_Ancestor_Essence) :

    Package_NS = BMT

    class _Attributes (_Ancestor_Essence._Attributes) :

        _Ancestor = _Ancestor_Essence._Attributes

        class left (_Ancestor.left) :
            """Person setting a trap."""

            role_type     = Person
            auto_cache    = MOM.Role_Cacher \
                ( attr_name       = "setter"
                , other_role_name = "middle"
                )

        # end class left

        class middle (_Ancestor.middle) :

            role_type     = Trap
            max_links     = 1

        # end class middle

        class right (_Ancestor.right) :
            """Location where a trap is set."""

            role_type     = Location
            auto_cache    = MOM.Role_Cacher (other_role_name = "middle")

        # end class right

    # end class _Attributes

# end class Person_sets_Trap_at_Location

def show (e) :
    if isinstance (e, (list, TFL._Q_Result_)) :
        print "[%s]" % (", ".join (str (x) for x in e), )
    else :
        print str (e)
# end def show

### All classes defining `__getslice__` have been changed to be
### compatible to Python 3.x by changing `__getitem__` to deal with
### slices
###
### Unfortunately, in Python 2.x `__getslice__` is still necessary and
### code like::
###
###     self.kill_callback [:]
###
### triggers the warning::
###
### DeprecationWarning: in 3.x, __getslice__ has been removed; use __getitem__
###
import warnings
warnings.filterwarnings \
    ( "ignore", "in 3.x, __getslice__ has been removed; use __getitem__")
if 0 :
    warnings.filterwarnings \
        ( "error",  "comparing unequal types not supported in 3.x")

### Because the example classes are all defined here and not in their
### own package namespace, we'll fake it
BMT._Export ("*")

NL = chr (10)

### __END__ MOM.__doc__
