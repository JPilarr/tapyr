MOM To-Do
=========

- TFL.Meta.Object

  + context manager `let` for temporarily setting attribute values

* Id_Entity: `pid` (persistent id)

  + set by EMS/DBW

  + globally unique per database (not reused!, survives save/load cycle)

* SCM

  + add `cid` (change id)

    - set by EMS/DBW

    - same semantics as `Id_Entity.pid`

    - independent namespace as `Id_Entity.pid`

  + reuse for tracking changes over database lifecycle

    - Attributes: cid, time, user, delta, pid

  + store `Id_Entity.pid` instead of `epk` (formally `names`) to refer to
    entity changed

  + `Id_Entity` gets attribute `last_change` (value `cid`)

- EMS/DBW

  * EMS manages DBW

    + Scope only has EMS attribute

      - remove `.dbw`

    + App_Type still has EMS and DBW

    + Scope creation::

        ### Create scope by loading from existing database
        Scope (app_type, db_uri, user = None)

        ### Create new scope with new database
        Scope.new (app_type, db_uri, root_epk = None, user = None)

    + Scope passes `db_uri` to `EMS`::

          self.ems = app_type.EMS (self, db_uri)

  * `app_type.DBW.create_database` -> session

  * `app_type.DBW.connect_database` -> session

  * `scope.ems.commit`

  * provide Id_Entity.pid

  * store SCM.Change objects

  * provide interface to check if the DB has asynchronous changes of an
    entity

    + `async_changes (entity)` returns a list of changes between the state of
      the object as read from the database and the state as current in the
      database

- Link, M_Link, Role:

  x Set `is_relevant` of all roles to True

  x Define Alias_Property for `hpk` that maps to `id` derived from objects
    linked

  x Is `Id_Entity.rename` correct for links ?

  x Implement `epk_to_hpk` to translate from `epk` to `hpk`

  x auto_cacher

  x check_type

  x Link3

  x Link2_Ordered

  * Link_AB

  * dfc_synthesizer

  x destroy_links / destroy_dependency

- Queries:

  * E_Type_Manager query methods::

      Method                Remarks
      ============          ===================================================
      query                 replaces `s_extension`, `t_extension`
      count                 replaces `s_count, `t_count`, `accepts filter
                            criteria
      instance              unchanged
      exists                unchanged
      role queries          unchanged
      ============          ===================================================

  * s_extension, etc. should return Q_Result objects

  x Q_Result is

    x instantiated with an iterable

    x iterable, re-iterable

      x if instantiated with something that isn't re-iterable needs to cache

    x can be filtered

      x result of `filter` is another Q_Result

    x can be sorted

      x order_by: specifies `sort_key`, but doesn't do any sorting yet

      x iter: return query result sorted by `sort_key` defined by `order_by`

- M_Entity vs. M_E_Type:

  x Entity defines the specification of the essential class (`E_Spec`)

  x E_Type is automagically created without inheriting from Entity

    x There is an empty class hierarchy of bare essential E_Types (just
      containing `Essence` attributes)

      x The bare essential E_Type replaces the `E_Spec` in the appropriate
        package namespace and module.

    x For each DBW backend to support, a separate subclass of the essential
      E_Type is automagically derived, which contains the DBW specific
      attribute descriptors

      x The essential E_Type gets the meta-processed predicates

      x `Essence` refers to the bare essential E_Type

    + Support for multiple app-types (like in TOM) can be implemented the
      same way:

      # For each app-type, there is a class hierarchy of app-type specific
        E_Types, each defined thus:

        - `__dict__` is Entity.__dict__ updated with ATS.__dict__, except for
          _Attributes and _Predicates

        - derived from the bare essential E_Type and the app-type specific
          ancestor E_Types

      # For each DBW backend to support, a separate subclass of the app-type
        specific E_Type is automagically derived, which contains the DBW
        specific attribute descriptors

  x M_Entity __init__/__new__ does very little apart from remembering the
    essential classes (in the class attribute _M_Extension)

  x M_E_Type __init__/__new__ sets up the meta information for the essential
    classes

  x E_Type_Manager implements the basic query methods

    x Delegation to EMS-manager of scope

    x Subclasses of M_E_Type_Id implemented object- and link-specific query
      methods

x Id_Entity renaming:

  x `rename` isn't a method of the public API

  x `set` and `set_raw` need to deal with changes in primary key attributes

  x Assignment to primary key attributes is forbidden

x Attr.Kind:

  x remove all dependencies on `obj._attr_man.attr_values [self.attr_dict_name]`

x Scope:

  x Scope just holds (dbw-specific) managers for objects and links

  x change signature of `remove` and `rename`

  x use `.epk` instead of `.name` to identify objects

  x keyed-entities just call `self.home_scope.add (self)`

    x For objects, there is a manager object that manages a hash-table of
      objects (analogous to the meta-link).

    x This architecture also allows separate hash-tables for different object
      types (using several managers).

x App_Type

  x Dictionary PNS_Set mapping the fully qualified names of essential package
    namespaces to the namespaces in question

  x Use `entity_type` instead of `etype` as method name

? Dependency management: move to DBW-Mixin for Scope

      x referential integrity

        x `_destroy` uses `notify_dependencies_destroy`

        x `rename` uses `self.dependencies` to call `update_dependency_names`

      x fixed: `has_substance` uses `self.dependencies`

x count: move to DBW-Mixin for Scope

x Replace `default_sort_key` (essential attribute) by class attribute
  `sorted_by`

  x Implement `Sorted_By` to interpret list of attribute names as
    sort-key (including `-name` for reverse sorting for some attributes)

x Simplify attribute handling ?

  x Move pickle handling out of Entity

  x `set` only handles cooked values

  x `on_error` callback for `set` and `set_raw` instead of
    `raise_exception`

- Documenter:

  x separate from Entity

  * Need to replace references to `obj.Documenter`

    (like in MOM.Error.Invariant_Error)

- MOM.Error:

  * change doc-strings to describe the error

- Rewrite pickling

  * Inject after_init_db into Entity

  * Implement pickling/unpickling of entities

### __END__ to-do
