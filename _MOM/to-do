MOM To-Do
=========

- Open questions:

- Link, M_Link, Role:

  * Set `is_relevant` of all roles to True

  * Define Alias_Property for `hpk` that maps to `id` derived from objects
    linked

  * Change role to provide `.type_name` and `.type_base_name`

    (in TOM `role.type_name` has the value of `role.role_e_type.type_base_name`)

- M_Entity vs. M_E_Type:

  x Entity defines the specification of the essential class (`E_Spec`)

  * E_Type is automagically created without inheriting from Entity

    x The essential E_Type.__dict__ is filled with contents of
      Entity.__dict__ except for `_Attributes` and `_Predicates`

      x The essential E_Type gets the meta-processed predicates

      x `Essence` refers to the essential E_Type

      x The essential E_Type replaces the `E_Spec` in the appropriate package
        namespace and module.

    + For each DBW backend to support, a separate subclass of the essential
      E_Type is automagically derived, which contains the DBW specific
      attribute descriptors

    + Support for multiple app-types (like in TOM) can be implemented the
      same way:

      # There is an empty class hierarchy of essential E_Types (just
        containing `Essence` attributes)

      # For each app-type, there is a class hierarchy of app-type specific
        E_Types, each defined thus:

        - `__dict__` is Entity.__dict__ updated with ATS.__dict__, except for
          _Attributes and _Predicates

        - derived from the essential E_Type and the app-type specific
          ancestor E_Types

      # For each DBW backend to support, a separate subclass of the app-type
        specific E_Type is automagically derived, which contains the DBW
        specific attribute descriptors

  x M_Entity __init__/__new__ does very little apart from remembering the
    essential classes (in the class attribute _M_Extension)

  x M_E_Type __init__/__new__ sets up the meta information for the essential
    classes

  * M_E_Type_Id implements the basic query methods

    + Delegation to EMS-manager of scope

    + Subclasses of M_E_Type_Id implemented object- and link-specific query
      methods

x Id_Entity renaming:

  x `rename` isn't a method of the public API

  x `set` and `set_raw` need to deal with changes in primary key attributes

  x Assignment to primary key attributes is forbidden

x Attr.Kind:

  x remove all dependencies on `obj._attr_man.attr_values [self.attr_dict_name]`

- Scope:

  * Scope just holds (dbw-specific) managers for objects and links

  * change signature of `remove` and `rename`

  * use `.epk` instead of `.name` to identify objects

  * keyed-entities just call `self.home_scope.add (self)`

    + For objects, there is a manager object that manages a hash-table of
      objects (analogous to the meta-link).

    + This architecture also allows separate hash-tables for different object
      types (using several managers).


- Dependency management: move to DBW-Mixin for Scope

      # referential integrity

        = `_destroy` uses `notify_dependencies_destroy`

        = `rename` uses `self.dependencies` to call `update_dependency_names`

      # `has_substance` uses `self.dependencies`

- count: move to DBW-Mixin for Scope

- Replace `default_sort_key` (essential attribute) by class attribute
  `sorted_by`

  x Implement `Sorted_By` to interpret list of attribute names as
    sort-key (including `-name` for reverse sorting for some attributes)

x Simplify attribute handling ?

  x Move pickle handling out of Entity

  x `set` only handles cooked values

  x `on_error` callback for `set` and `set_raw` instead of
    `raise_exception`

- Documenter:

  x separate from Entity

  * Need to replace references to `obj.Documenter`

    (like in MOM.Error.Invariant_Error)

- MOM.Error:

  * change doc-strings to describe the error

- Rewrite pickling

  * Inject after_init_db into Entity

  * Implement pickling/unpickling of entities

### __END__ to-do
